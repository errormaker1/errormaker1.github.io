<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://errormaker1.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="柯艺阳">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://errormaker1.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-编程思想—递推、递归”" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/19/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E9%80%92%E6%8E%A8%E3%80%81%E9%80%92%E5%BD%92%E2%80%9D/" class="article-date">
  <time class="dt-published" datetime="2021-08-18T16:03:39.000Z" itemprop="datePublished">2021-08-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/19/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E9%80%92%E6%8E%A8%E3%80%81%E9%80%92%E5%BD%92%E2%80%9D/">编程思想—递推、递归”</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>编程思想：如何利用书写模式，来解决对应的需求问题，然后利用代码实现对应的数据模型（逻辑）。<br>算法：使用代码实现对应的数学模型，从而解决对应的业务问题<br><strong>递推算法</strong><br>通过已知条件，利用特定关系得出中间推理，直至得到结果的算法。递推算法分为顺推和逆推两种<br>顺推：通过最简单的条件（已知），然后逐步推演结果<br>逆推：通过结果找到规律，然后推到已知条件</p>
<p>斐波那契数列：1 1 2 3 5 8 13…，通常需求：请求的指定位置n所对应的值是多少<br>找规律：<br>1、    第一个数是1<br>2、    第二个数也是1<br>3、    从第三位开始：属于前两个数的和</p>
<p><strong>代码解决思路</strong><br>1、    如果数字位置为1和2，结果都是1<br>2、    从第三个开始，想办法得到前两个的结果，就可以得到<br>终极解决办法：想办法把要求的位置之前的所有的值都列出来，那么要求的数就可以通过前两个的和计算出来，使用数组存储数据就行<br><em><strong>递归思想</strong></em><br>递归算法是吧问题转化为规模缩小了的同类问题的子问题。然后递归调用函数（或过程）来表示问题的解<br>1、    简化问题：找到最优子问题（不能再小）<br>2、    函数自己调用自己<br>斐波那契数列：1 1 2 3 5 8 13..<br>求指定位置的数列的值<br>规律：第一个和第二个为1，从第三个开始为前两个之和<br>F(N) = F(N-1)+F(N-2)<br>F(N-1) = F(N-2)+F(N-3)<br>…<br>F(2) = F(1)=1<br><strong>递归思想中有两个非常重要的点</strong><br>递归点：发现当前问题可以有解决当前问题的函数，去解决规模比当前小一点的问题来解决F(N)=F(N-1)+F(N-2)<br>递归出口：当问题解决的时候，已经到达（必须有）最优子问题，不能再次调用函数<br>如果一个函数递归调用自己而没有递归出口，就是死循环<br>递归的本质是函数调用函数，一个函数需要开辟一块内存空间，递归会出现同时调用n多个函数：递归的本质是利用空间换时间</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/19/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E9%80%92%E6%8E%A8%E3%80%81%E9%80%92%E5%BD%92%E2%80%9D/" data-id="ckshorr380001okvsfrqyhskt" data-title="编程思想—递推、递归”" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数组" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/15/%E6%95%B0%E7%BB%84/" class="article-date">
  <time class="dt-published" datetime="2021-08-15T15:59:37.000Z" itemprop="datePublished">2021-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/15/%E6%95%B0%E7%BB%84/">数组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Array，数据的组合，将一组数据（多个）储存到一个指定的容器中，用变量指向该容器，然后可以通过变量一次性得到该容器中的所有数据<br><strong>数组定义语法</strong><br>在php中系统提供了多种定义数组的方式：<br>1、    最常用：使用array关键字<br>$变量= array(元素1，元素2，…)<br>2、    可以使用中括号来包裹数据：<br>$变量 = [元素1，元素2，…]<br>3、    隐形定义数组：给变量增加一个中括号，系统自动变成数组<br>$变量[] = 值1;   //如果不提供下标也可以，就系统自动生成<br>$变量[下标] = 值;  //中括号里面的内容称之为下标key，该下标可以是字母或者数字，与变量命名规则相似<br><em>Php数组特点</em><br>1、    可以整数下标或者字符串下标<br>如果数组下标都为整数：索引数组<br>如果数组下标都为字符串：关联数组<br>2、    不同下标可以混合存在：混合数组<br>3、    数组元素的顺序以放入顺序为准，跟下标无关<br>4、    数字下标的自增长特性：从0开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大值+1开始<br>5、    特殊值下标的自动转换<br>布尔值：true/false<br>空：NULL<br>6、    php中数组元素没有类型限制<br>7、    php中数组元素没有长度限制</p>
<p><strong>补充</strong>：php中数组是很大的数据，所以存储位置是堆区，为当前数组分配一块连续的内存<br>多维数组<br>数组里面的元素又是数组<br>二维数组<br>数组中所有的元素都是一维数组<br>多维数组<br>在第二维的数组元素中可以继续是数组，在php中没有维度限制（php本质并没有二维数组）<br>但是不建议使用超过三维以上的数组，会增加访问的复杂度，降低访问效率<br>异形数组（不规则数组）<br>数组中的元素不规则，有普通基本变量也有数组。<br>在实际开发中，并不常用，尽量让数组元素规则化（便于进行访问）<br><em><strong>数组遍历</strong></em><br>普通数组数据的访问都是通过数组元素的下标来实现访问，如果说数组中所有的数据都需要依次输出出来，就需要我们使用到一些简化的规则来实现自动获取下标以及输出数组元素<br>$arr = array(0 =&gt;array(‘name’=&gt;’tom’),1=&gt;array(‘name’=&gt;’jim’))<br>访问一维方式：<br>$arr[一维下标]<br>$arr[0];   //结果：array(‘name’=&gt;’tom’);<br>访问二维方式：<br>$arr[一维下标][二维下标]<br>$arr[1][‘name’];   //结果jim<br><strong>Foreach遍历语法</strong><br>基本语法：<br>Foreach($数组变量 as$[下标 =&gt; ]$值){<br>    // 通过$下标访问元素的下标，通过$值访问元素的值<br>}<br><em>通常</em>：如果关联数组（字母下标），就需要下标，如果是数字下标直接访问值就行<br>在进行护具存储定义的时候，通常二维数组不会两个维度的key下标都为数字，一般是一维为数字，二维为字符串，所以在进行遍历的时候，通常是只需要针对一维进行遍历，取得二维数组元素，然后二维数组元素通过下标去访问<br><strong>Foreach遍历原理</strong><br>本质是数组内部有一颗指针，默认是指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针。<br>1、    foreach会重置指针，让指针指向第一个元素<br>2、    进入foreach循环，通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量中，将值取出来放到对应的值变量$v中；<br>3、    进入到循环内部，开始执行<br>4、    指针下移（本质在第二步之后，进入循环体之前 ）<br>5、    重复2和3，直到2的时候遇到指针取不到内容（指针指向数组最后 ）<br><strong>For循环遍历数组</strong><br>For循环：基于已知边界条件（起始和结束）然后有条件的变化（规律）<br>因此佛如循环遍历数组有对应条件<br>1、    获取数组长度：count（数组）得到数组元素的长度<br>2、    要求数组元素的下标是规律的数字<br><strong>While配合each和list遍历数组</strong><br>While是在外部定义边界条件，如果要实现可以和for循环一致<br>Each函数使用：each能够从一个数组中获取当前数组指针所指向的元素的下标和值，拿到之后将数组指针下移，同时将拿到的元素下标和值以一个四个元素的数组返回<br>List函数<br>数组的相关函数<br>1、    排序函数：<br>sort():顺序排序（下标重排）<br>rsort():逆序排序<br>assort():顺序排序（下标保留）<br>arsort():逆序排序<br>ksort()：顺序排队：按照键名（下标）<br>krsort():逆序排序<br>shuffle():随机打乱数组元素<br>2、    指针函数<br>Reset():重置指针，将数组指针回到首位<br>End():重置指针，将数组指针回到最后一位<br>Next():指针下移，取得下一个元素的值<br>Prev():指针上移，取得上一个元素的值<br>Current():获取当前指针对应的元素值<br>Key():获取当前指针对应的下标值<br>注意：next，prev会移动指针，可能导致超出数组，此时再使用next、prev便不能再返回数组，只 能通过end/reset<br>3、    其他函数<br>Count():统计数组中元素的数量<br>Array_push():往数组中加入一个元素（数组后面）<br>Array_pop()：往数组中取出一个元素（数组后面）<br>Array_shift()从数组中取出一个元素（数组前面）<br>Array_unshift()：从数组中加入一个元素（数组前面）<br>Php模拟数据结构<br>栈：压栈，先进去后出来（FNLO）first in last out<br>队列：排队陷进去的先出去（FIFO）first in first out<br>Array_reverse():数组元素反过来<br>In_array():判断一个元素在数组中是否存在<br>Array_keys():获取一个数组的所有下标，返回一个索引数组<br>Array_values()获取一个数组的所有值，返回一个所有数组</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/15/%E6%95%B0%E7%BB%84/" data-id="ckshorr330000okvsaop1fjru" data-title="数组" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-字符串类型“" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E2%80%9C/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T15:54:57.000Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E2%80%9C/">字符串类型“</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em><strong>字符串定义语法</strong></em><br>1、    单引号字符串：使用单引号包裹<br>2、    双引号字符串：使用双引号包裹<br>引号方式比较适合定义那些比较短（不超过一行）没有结构要求的字符串，如果有结构要求，或者内容超过一行，可以使用一下两种结构定义<br>3、    Nowdoc字符串：没有单引号的单引号字符串<br>4、    Heredoc字符串：没有双引号的双引号字符串<br>*Heredoc和nowdoc比引号还是区别多一点<br><em><strong>字符串转义</strong></em><br>在计算机通用协议中，有一些特定的方式定义的字母，系统会特定处理：通常这种方式都是使用反斜杠+字母（单词）的特性：<br>\r\n:回车换行<br>Php在识别转义字符的时候也是使用同样的模式：反斜杠+字母<br>在php中系统常用的转义符号：<br>\’:在单引号字符串中显示单引号<br>\”:在双引号字符串中显示双引号<br>\r:代表回车（理论上是回到当前行的首位置）<br>\n:代表新一行<br>\t:类似tab键，输出四个空格<br>$:在php中使用￥符号作为变量符号，因此需要特定识别<br><strong>单引号和双引号区别：</strong><br>1、    其中单引号中只能够识别;，而双引号中就不能识别、‘<br>2、    双引号中因为能够识别$符号,所以双引号中可以解析变量，而单引号不行<br><em>双引号中变量识别的规则</em><br>1、    变量本身系统能够与后面的内容区分：应该保证变量的独立性，不要让系统难以区分<br>2、    使用变量专业标识符（区分），给变量加上一组大括号<br><em>结构化定义字符串变量的规则</em><br>1、    结构化定义字符串对应的边界符有条件：<br>边界符后面不能跟任何内容、下边界符必须顶格、下边同样后面只能跟分号，不能跟任何内容；<br>2、    结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身<br><em>字符串长度问题</em><br>1、    基本函数strlen()：得到字符串的长度（字节为单位）<br>2、    多字节字符串的长度问题：包含中文的长度<br>3、    多字节字符串扩展模块：mbstring扩展(mb:Multi Bytes)<br>首先要加载php的nbstring扩展<br>Mbstring扩展针对的是一些关于字符统计：strlen只是针对标准交换码SACII，mtstring会针对不同的字符集<br><strong>字符串相关函数</strong><br>1、    转换函数：inplode(),explode(),str_split()<br>Implode（连接方式，数组）:将数组中的元素按照某个规则连接成一个字符串<br>Explode（分割字符，目标字符串）：将字符串按照某个格式进行分割，分成数组<br>中国|北京|顺义 == array(‘中国’,’北京’,’顺义’)；<br>Sre_spilt（字符串，字符长度）：按照指定长度拆分字符串得到数组<br>2、    截取函数：trim(),ltrim(),rtrim()<br>Trim(字符串，【指定字符】)：本身默认是用来去除两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边的内容，直到碰到一个不是目标字符为止<br>Ltrim：去除左边<br>Rtrim：去除右边<br>3、    截取函数：substr(),strstr()<br>Sunstr(字符串，起始位置从0开始，[长度]):指定位置开始截取字符串，可以截取指定长度（不截取到最后）<br>Strstr(字符串，匹配字符):从指定位置开始截取到最后（可以用来取文件后缀名）<br>4、    大小转换函数：strtolower(),strtoupper(),ucfirst()<br>Strtolower：全部小写<br>Strtoupper：全部大写<br>Ucfirst：首字母大写<br>5、    查找函数：strpos(),strrpos()<br>Strpos：判断字符在目标字符串中首次出现的位置<br>Strrpos:判断字符在目标字符串中最后出现的位置<br>6、    替换函数：str_replace()<br>Str_replace(匹配目标，替换的内容，查找目标):将目标字符串中部分字符串进行替换<br>7、    格式化函数：printf(),sptintf()<br>Printf/sprint（输出字符串有占位符，顺序占位内容….）：格式化输出数据<br>8、    其他：str_repeat(),str_shuffle()<br>Str_repeat（）:重复某个字符串n次<br>Str_shuffle（）：随机打乱字符串</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E2%80%9C/" data-id="ckshojkhs0000p0vsgw5k3z0e" data-title="字符串类型“" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/" rel="tag">字符串类型</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-函数" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/09/%E5%87%BD%E6%95%B0/" class="article-date">
  <time class="dt-published" datetime="2021-08-09T03:12:19.000Z" itemprop="datePublished">2021-08-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/09/%E5%87%BD%E6%95%B0/">函数</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>函数function是一种语法结构，将实现某一个功能的代码块封装到一个结构中，实现代码的重复利用（复用）<br><em><strong>函数定义语法</strong></em><br>函数有几个对应的关键点：function关键字，函数名，参数（形参和实参），函数体和返回值<br>基本语法如下<br>Function 函数名（【参数】）{<br>       //函数体<br>       //返回值：return结果<br>}</p>
<p>定义函数的目的是为了实现代码的重复利用，一个功能一个函数（简单明了）<br><strong>函数的使用</strong><br>通过访问函数的名字+（）；如果函数在定义的过程中有参数，那么在调用的时候就必须传入参数；函数是一种结构，不会自动运行，必须通过调用才会执行<br>函数是在代码执行阶段，碰到函数名字的时候才会调用，不是在编译阶段<br>函数的调用特点，只要系统在内存中能够找到对应的函数就可以运行，（函数的调用可以在定义之前）</p>
<p><strong>函数执行的内存分析：</strong><br>1、读取代码进入到代码段（编译：将代码编程字节码存储到内存）<br>2、根据代码逐行执行<br>以上原因：编译和执行是分开的（先编译后执行）</p>
<p><strong>函数命名规范</strong><br>由字母、数字和下划线组成，但是不能以数字开头<br>函数作为一种常用结构，一般遵循一下规则：函数通常名字代表这函数的功能，而有些功能会比较复杂，可能一个单词不足以表达，需要多个组合<br>1、驼峰法：除了左边第一个单词外，后面所有的单词首字母都大写：showParent（）<br>2、下划线法：单词之间通过下划线连接，其他单词都是小写show_parent（）</p>
<p>函数名字：在一个脚本周期中不允许出现同名函数（通常在一个系统开发中都不会使用同名函数）</p>
<p><em><strong>参数详解</strong></em><br>函数的参数分为两种：形参和实参<br><em>形参</em><br>形式参数，不具有实际意义的参数，是在函数定义时使用的参数<br><em>实参</em><br>实际参数，具有实际数据意义的参数，是在函数调用时使用的参数<br>形参是实参的载体，实参在调用时通常是需要传入到函数内部参与计算（运算），那么需要在函数内部去找到实际数据所在的位置才能找到数据本身，需要实际调用的时候将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据。<br><strong>注意</strong><br>1、在php中允许实参多于形参（个数），函数内部不用而已<br>2、在php中理论上形参个数没有限制（实际开发不会太多）<br>3、实参不能少于形参个数</p>
<p><strong>默认值</strong><br>Default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值，如果实际调用的传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。<br>通常默认值是用在一些，一定会有某个数据参与，但是可能通常是某个我们知道的值<br><em>注意事项</em><br>1、默认值的定义是放在最右边的（多个），不能左边形参有默认值，但是右边没有</p>
<p>函数外部定义的变量名字与函数定义的形参名字冲突（同名）是没有任何关联关系的，如果多个函数使用同样的形参名字也不冲突。<br><em><strong>引用传递</strong></em><br>实参在调用时会将值赋值给形参，那么实际上使用的方式就是一种简单的值传递，将实参（如果是变量或者常量或者其他表达式）的结果（值）取出来赋值给形参，形参与外部实际传入的参数本身没有任何关联关系：只是结果一样。<br>有的时候希望在函数内部拿到的外部数据，能够在函数内部改变，那么就需要明确告知函数（定义时），函数才会在调用的时候去主动获取外部数据的内存地址，以上这种定义形式参数的方法叫引用传值。<br>基本定义语法：<br>Function 函数名（形参1，&amp;形参2）{<br>      函数体<br>}<br>在调用的时候必须给引用传值的参数位置传入之际参数，而且参数本身必须是变量（变量才有指向的数据的内存地址）<br>引用传值注意事项：在传入实参的时候必须传入变量<br><em>函数体</em><br>函数内部{}大括号里面的所有代码都称之为函数体<br>函数体内基本上所有的代码都可以实现<br>定义变量、常量，使用流程控制<br><em>函数返回值</em><br>Return，指的是将函数实现的结果，通过return关键字，返回给函数外部（函数调用处）：在php中所有的函数都有返回值。（如果没有明确return使用，那么系统默认返回NULL）<br>返回值作用：将计算结果返回给调用处<br>注意：函数的返回值可以是任意数据类型<br>Return关键字：<br>1、return在函数内部存在的价值是返回当前函数的结果（当前函数运行结束）<br>2、Retrun还可以在文件中直接使用（不在函数里面），代表文件将结果return后面跟的内容，转交给包含当前文件的位置。（通常在系统配置文件中使用较多），在文件中也代表种植文件后面的代码：return之后的内容不会执行<br><em><strong>作用域</strong></em><br>变量（常量）能够被访问的区域<br>1、变量可以在普通代码中定义<br>2、变量也可以 在函数内部定义<br>在php中作用域严格来说分为两种：但是php内部还定义一些在严格意义之外的一种，中共有三种<br>1、全局变量：就是用户普通定义的变量（函数外部定义）<br>所属全局空间：在php中只允许在全局空间使用：理论上函数内部不可方法<br>脚本周期：直到脚本执行结束（最后一行代码执行完）<br>2、局部变量：在函数内部定义的变量<br>所属当前函数空间：在php中只允许在当前函数自己内部使用<br>函数周期：函数执行结束（函数是在栈区中开辟独立内存空间运行）<br>3、超全局变量：系统定义的变量（预定义变量：$_SERVER、$_POST…）<br>所属超全局空间：没有访问限制（函数内外都可以访问）<br>超全局变量会将全局变量自动纳入到$GLOBALS里面，而$GLOBALS没有作用域限制，所有能够帮助局部去访问全局变量，但是必须使用数组方式<br>如果想函数内部使用外部变量：除了$GLOBALS之外，通过参数传值（如果要统一战线还可以使用引用传值）<br>在php中，其实还有一种方式，能够实现全局访问局部，同时局部也可也访问全局：<em>global关键字</em><br>Global关键字：是一种在函数里面定义变量的一种方式<br>1、如果使用global定义的变量名，在外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（同一个变量）；<br>2、如果使用global定义的变量名在外部不存在，系统会自动在全局空间定义一个与这个局部变量同名的全局变量<br>本质的形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。<br>基本语法<br>Global 变量名；  //不能赋值<br>变量名 = 值<br><strong>静态变量</strong><br>Static，在函数内部定义的变量，使用static关键字修饰，用来实现跨函数共享数据的变量：函数运行结束所有局部变量都会清空，如果重新运行函数，所有的局部变量又会重新初始化。<br>原理：静态变量原理：系统在进行编译的时候，就已经对static这一行进行了初始化：即为静态变量赋值，而在执行时，会跳过初始化这一行。<br><strong>可变函数</strong><br>当前有一个变量所保存的值刚好是一个函数的名字，那么就可以使用变量＋（）来充当函数名使用<br>$变量= display<br>Function display(){<br>}<br>$变量（）;<br>可变函数在系统使用的过程中哈斯比较多的，尤其是使用很多系统函数的时候，需要用户只是外部定义一个自定义函数，但是是需要传入到系统函数内部使用。<br><strong>匿名函数</strong><br>没有名字的函数<br>基本语法：<br>变量名 = function(){<br>   函数体<br>};<br>变量保存匿名函数，本质得到的是一个对象（closure）<br><strong>闭包</strong><br>要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定地计算环境。（简单理解就是说，函数内部的一些局部变量即要执行的代码块，在执行完毕后没有被释放）。没有被释放的原因是：在函数内部，还有对应的函数被引用，通常为匿名函数。<br>简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部有对应的函数在引用（函数的内部函数：匿名函数）<br>证明：函数的局部变量在函数使用完之后没有被释放？<br>1、使用内部匿名函数<br>2、匿名函数使用局部变量<br>3、匿名函数被返回给外部使用<br><strong>伪类型</strong><br>假类型，实际上在php中不存在的类型。但是通过伪类型可以帮助程序员更好的查看操作手册从而更方便学习。<br>伪类型主要有两种：<br>Mixed：混合的，可以是多种php中的数据类型<br>Number：数值的，可以是任意数值类型（整形和浮点型）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/09/%E5%87%BD%E6%95%B0/" data-id="cks42dqwj0000nkvsai9g81ct" data-title="函数" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%87%BD%E6%95%B0/" rel="tag">函数</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-文件包含" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" class="article-date">
  <time class="dt-published" datetime="2021-08-07T03:06:01.000Z" itemprop="datePublished">2021-08-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/">文件包含</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在一个PHP脚本中，将另外一个文件包含进来，合作完成一件事情。<br><strong>文件包含作用</strong><br>1、要么使用被包含文件中的内容，实现代码共享，向上包含（索要）<br>2、要么自己的东西可被使用，向下包含（给予）：自己有某个东西需要别的脚本显示。<br>最大的作用是分工协作，共同完成一件事情。<br><strong>文件包含四种形式</strong><br>Include、include_once、require、require_once</p>
<p><em><strong>include 和 require区别</strong></em><br>include会执行多次，导致报错（重复定义变量）。。而include_once不会出现这种情况。 require和include区别在于：若未包含文件，则报错形式不一样。（require包含错误文件，则include后不 再执行；include未包含文件，会警告，但是仍会执行后面的。）<br><strong>文件加载路径</strong><br>文件加载时需指定文件路径，才能保证PHP正确找到对应的文件。<br>1、绝对路径（从磁盘根目录开始—本地绝对路径；从网站根目录开始—网络绝对路径–相对于/的路 径，，/相当于绝对路径）<br>2、相对路径：从当前文件所在目录开始的路径.或者./表示当前文件夹，../上级目录<br>绝对路径和相对路径加载区别：绝对路径相对效率偏低（因为要从跟目录开始找，但相对安全，路径固定）</p>
<p><strong>文件嵌套包含</strong><br>嵌套包含的时候就很容易出现相对路径出错的问题：相对路径会因为文件的包含而改变（./和../）：windows下面，每一个文件夹都有.和..的文件夹。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" data-id="cks425iqu0000cwvs6rmeangh" data-title="文件包含" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" rel="tag">文件包含</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-流程控制-循环结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/05/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-08-05T03:04:59.000Z" itemprop="datePublished">2021-08-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/05/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/">流程控制-循环结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>代码段再一定的控制下，可以多次执行<br>For循环、while循环、do-while循环、foreach循环</p>
<p><em><strong>For循环</strong></em><br><strong>基本语法：</strong>for（条件表达式1：基本表达式2：条件表达式3）{<br>        //条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可<br>//条件表达式2：边界判定，限制循环执行的次数<br>//条件表达式3：用来执行条件变化<br>//循环体<br>}<br>1、执行条件表示式1：定义初始化条件（只有一次）<br>2、执行条件表达式2：判断条件N次<br>   2.1满足：执行循环体<br>   2.2不满足条件：循环结束<br>3、执行循环体（n次）<br>4、执行条件表达式3：循环变量变化<br>5、重复2-4<br>For循环特殊使用：for循环中对应的括号（条件）可以一个都没有（死循环）<br>For（；；）{</p>
<p>}</p>
<p><em><strong>While循环</strong></em><br><strong>基本语法：</strong><br>条件初始化；<br>while（条件表达式）{<br>     //条件表达式就是判断边界条件<br>    循环体；   //循环条件的变化<br>}<br>For与while的选择<br>1、如果是基于固定已知条件（数值而且是有规律的变化），用for循环<br>2、While可以做灵活的条件判定（while使用的比较多）</p>
<p><em><strong>Do-while循环</strong></em><br>看着很像while，while先进行条件判定然后执行循环体，有可能出现第一次就条件不满足，那么就会直接失败（循环体一次都不执行）。Do-while就是先执行循环体后判断条件（至少执行一次循环体）</p>
<p><strong>Do-while基本语法</strong><br>do{<br>   //循环体<br>}while（条件表达式）；</p>
<p>循环结构<br>循环控制：在循环内部对循环本身进行控制<br>中断控制：重新开始循环，循环体中还有其他内容，也不再执行<br>Continue层级：//默认是1（循环可以多层嵌套）</p>
<p>中止控制：循环直接结束<br>Break层级；//默认是1</p>
<p>因为循环经常性会碰到嵌套（循环中间包含循环），如果在循环内部有些条件下，明确可以知道当前循环（或者说外部循环）不需要继续执行了，那么就可以使用循环控制来实现：其中内部循环也可以控制到外部，就是通过使用层级参数。<br>Continue2； 当前自己循环后面内部不再执行，同时外部循环如果还有循环体也不再执行，重新来过<br>Break2；当前自己循环结束，外部也结束</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/05/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" data-id="cks421dl40000j8vs1ct79ach" data-title="流程控制-循环结构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" rel="tag">循环结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-流程控制-分支结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/01/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-08-01T06:04:23.000Z" itemprop="datePublished">2021-08-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/01/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/">流程控制-分支结构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在php中，分支结构主要有两种，<em><strong>if分支和switch分支</strong></em><br><strong>If</strong>：如果的意思，给定一个条件同时为该条件设置多种（两种）情况，然后通过条件判断来实现具体的执行段.</p>
<p><strong>最简if</strong>：只有一段代码，但是可以选择是否执行<br>If（条件表达式）{代码<br>         //满足条件所要执行的内容；//顺序结构<br>}</p>
<p><strong>基础if</strong>：有两面性，满足条件或不满足条件都有对应的执行代码<br>If（条件表达式）{<br>     //满足条件后执行的代码段；<br>}else{<br>    // 不满足条件执行的代码段；<br>}</p>
<p><strong>复杂if</strong>：在判断条件之后，通常就有两种结果：满足或不满足，在不满足之后还可以再次进行条件判断<br>If（条件表达式1）{<br>       //满足条件表达式1的代码段；<br>}elseif（条件表达式2）{<br>       //不满足表达式1条件，但是满足表达式2的代码；<br>}…//可以使用多个elseif来进行再次条件筛选<br>Else{<br>      //全部不满足要执行的代码；<br>}</p>
<p><em><strong>注意</strong></em>：如果条件特别多才会采用复合if形式<br>1、如果条件比较单一（同一个条件），会采用elseif复合方式<br>2、判断条件不一致，建议使用嵌套语法（不宜有太多层嵌套，不美观）<br>If分支，适用于所有条件判断（分支结构）</p>
<p><strong>Switch分支</strong>：有一组情形存在，通过一个条件，通常有多个值，但是每一个值都会有对应不同的代码要执行。<br>Switch判断方式：是将条件放到分支结构内部判断<br><strong>Switch基本语法：</strong><br>switch（条件表达式）{<br>     //所有判断：逐个进行<br>     Case 值1：                     //当前表达式的结果与值1相等（==）<br>            要执行的代码段；<br>            Break;                   //在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码），需要中断执行，break表示中断switch<br>     Case 值2：<br>            要执行的代码段；<br>            Break<br>            Default：       //都匹配失败输出的内容<br>           Break<br>     ….<br>}</p>
<p><em><strong>If和switch的选择</strong></em><br>1、if能做所有的分支结构事情<br>2、Switch处理的是条件比较多，同时比较单一，而且是固定值匹配的分支结构</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/08/01/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/" data-id="ckrssx8400000p4vsasaw7rcw" data-title="流程控制-分支结构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/" rel="tag">分支结构</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-数据与运算符" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/25/%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" class="article-date">
  <time class="dt-published" datetime="2021-07-25T05:09:53.000Z" itemprop="datePublished">2021-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/25/%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/">数据与运算符</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em><strong>在php中将数据分为三大类八小类</strong></em><br>简单（基本）数据类型：4个小类**(整型、浮点型、字符串型、布尔类型)**<br>复合数据类型：2个小类**(对象类型、数组类型)**<br>特殊数据类型：2个小类**(资源类型、空类型)**</p>
<p><em><strong>逻辑运算符:</strong></em>&amp;&amp;：逻辑<strong>“与”</strong>、||：逻辑<strong>“或”</strong>、！逻辑<strong>“非”</strong><br><em><strong>连接运算符:</strong></em><br><strong>“.”</strong>将两个字符串连接到一起<br><strong>“.=”</strong>复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量<br><em><strong>错误抑制符:</strong></em> <strong>“@()”</strong>在可能出错的表达式前面用即可<br><em><strong>三目运算符</strong></em><br><strong>语法格式：  表达式1? 表达式2：表达式3；</strong><br>运算如果表达式1成立，那么执行表达式2，否则执行表达式3；<br>注意：如果表达式本身比较复杂。建议使用括号包起来<br><em><strong>自操作运算符</strong></em><br><strong>“++”</strong>在原来的值上+1<br><strong>“–”</strong>在原来的值上-1<br>前置自操作：先把自己改变，然后把改变后的值给别人<br>后置自操作：先把自己所保存的值留下了，然后改变自己，自己给别人的是原来的值</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/07/25/%E6%95%B0%E6%8D%AE%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/" data-id="ckrire5qr00000kvsg0iychcg" data-title="数据与运算符" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE/" rel="tag">数据</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">运算符</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-变量与常量" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/14/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/" class="article-date">
  <time class="dt-published" datetime="2021-07-14T06:03:30.000Z" itemprop="datePublished">2021-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PHP/">PHP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/14/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/">变量与常量</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><em>$var =                      对变量var定义</em><br><em>unset（变量名字）            删除变量</em></p>
<hr/>

<p>变量传值一共有两种方式：<strong>值传递，引用传递</strong><br><strong>值传递</strong>：($a = $b)将变量保存的值复制一份，并将该值给另外一个变量保存(两个变量无关系)<br><strong>引用传递</strong>：($a = &amp;$b)将变量保存值所在的内存地址传递给另外一个变量，两个变量同指一块内存（名字不一样而已）。</p>
<p><strong>定义常量</strong><br>1、<strong>define(‘常量名’，常量值)</strong><br>2、<strong>const 常量名=值</strong><br>常量的使用和变量一样，但不可改变值，在定义的时候就要进行赋值，在对特殊名字进行访问的时候不能用echo直接输出，要用访问常量函数：constant(‘常量名’)<br><strong>魔术常量</strong>：由双下划线+常量名+双下划线组成，其值会随着环境变化而变化，我们无法改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/07/14/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/" data-id="ckr333taf0000a8vs5vzdfivr" data-title="变量与常量" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%98%E9%87%8F/" rel="tag">变量</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%B8%B8%E9%87%8F/" rel="tag">常量</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-初步认识php" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/12/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86php/" class="article-date">
  <time class="dt-published" datetime="2021-07-12T14:26:04.000Z" itemprop="datePublished">2021-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/12/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86php/">了解web基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Web分为两类：静态网站和动态网站。流程:浏览器发起访问-&gt;DNS解析域名-&gt;服务器电脑-&gt;服务软件<br>静态网站访问流程图<br><img src="images/%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%B5%81%E7%A8%8B%E5%9B%BE.png"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://errormaker1.github.io/2021/07/12/%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86php/" data-id="ckr0q41za0000jwvs33yq9btd" data-title="了解web基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%87%BD%E6%95%B0/" rel="tag">函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/" rel="tag">分支结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%98%E9%87%8F/" rel="tag">变量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/" rel="tag">字符串类型</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E9%87%8F/" rel="tag">常量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" rel="tag">循环结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE/" rel="tag">数据</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" rel="tag">文件包含</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/" rel="tag">运算符</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E5%BD%92/" rel="tag">递归</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%80%92%E6%8E%A8/" rel="tag">递推</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/%E5%87%BD%E6%95%B0/" style="font-size: 10px;">函数</a> <a href="/tags/%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/" style="font-size: 10px;">分支结构</a> <a href="/tags/%E5%8F%98%E9%87%8F/" style="font-size: 10px;">变量</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B/" style="font-size: 10px;">字符串类型</a> <a href="/tags/%E5%B8%B8%E9%87%8F/" style="font-size: 10px;">常量</a> <a href="/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/" style="font-size: 10px;">循环结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE/" style="font-size: 10px;">数据</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 10px;">数组</a> <a href="/tags/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/" style="font-size: 10px;">文件包含</a> <a href="/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/" style="font-size: 10px;">运算符</a> <a href="/tags/%E9%80%92%E5%BD%92/" style="font-size: 10px;">递归</a> <a href="/tags/%E9%80%92%E6%8E%A8/" style="font-size: 10px;">递推</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/19/%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E2%80%94%E9%80%92%E6%8E%A8%E3%80%81%E9%80%92%E5%BD%92%E2%80%9D/">编程思想—递推、递归”</a>
          </li>
        
          <li>
            <a href="/2021/08/15/%E6%95%B0%E7%BB%84/">数组</a>
          </li>
        
          <li>
            <a href="/2021/08/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E2%80%9C/">字符串类型“</a>
          </li>
        
          <li>
            <a href="/2021/08/09/%E5%87%BD%E6%95%B0/">函数</a>
          </li>
        
          <li>
            <a href="/2021/08/07/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/">文件包含</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 柯艺阳<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>